

vs_1_1

def c94, 3, 1, 0, 0

dcl_position v0
dcl_blendweight v1
dcl_blendindices v2
dcl_normal v3
dcl_texcoord v4

mul r5, v2, c94.x
mov a0.x, r5.y
dp3 r1.x, c7[a0.x], v3
dp3 r1.y, c8[a0.x], v3
dp3 r1.z, c9[a0.x], v3
mul r1.xyz, r1, v1.y
dp3 r2.x, r1, r1
rsq r1.w, r2.x
mul r2.xyz, r1, r1.w
mov a0.x, r5.x
dp3 r1.x, c7[a0.x], v3
dp3 r1.y, c8[a0.x], v3
dp3 r1.z, c9[a0.x], v3
mad r1.xyz, r1, v1.x, r2
dp3 r2.x, r1, r1
rsq r1.w, r2.x
mul r1.xyz, r1, r1.w
dp3 r1.x, r1, c4
max r1.w, r1.x, c94.z
mov r2.xyz, v0
mov r2.w, c94.y
add r1, r1.w, c6
mov a0.x, r5.y
dp4 r3.x, c7[a0.x], r2
dp4 r3.y, c8[a0.x], r2
dp4 r3.z, c9[a0.x], r2
mul r4.xyz, r3, v1.y
mov a0.x, r5.x
dp4 r3.x, c7[a0.x], r2
dp4 r3.y, c8[a0.x], r2
dp4 r3.z, c9[a0.x], r2
mad r3.xyz, r3, v1.x, r4
mov a0.x, r5.z
dp4 r0.x, c7[a0.x], r2
dp4 r0.y, c8[a0.x], r2
dp4 r0.z, c9[a0.x], r2
mad r3.xyz, r0, v1.z, r3
mov a0.x, r5.w
dp4 r0.x, c7[a0.x], r2
dp4 r0.y, c8[a0.x], r2
dp4 r0.z, c9[a0.x], r2
mad r0.xyz, r0, v1.w, r3
mov r0.w, c94.y
mul oD0, r1, c5
dp4 oPos.x, c0, r0
dp4 oPos.y, c1, r0
dp4 oPos.z, c2, r0
dp4 oPos.w, c3, r0
mov oT0.xy, v4


//The vertex shader has been generated by this hlsl code, and small
//optimisation gave been done manually:
//you can compile with the command :
//
//fxc /Tvs_1_1 VertexShader.fx /Fc dx9_vs1_1.vsa /Zpr
//
//#define MAXBONES 29
//
//struct appdata  {
//  float3 Position: POSITION;
//  float4 Weight:BLENDWEIGHT;
//  float4 Indices:BLENDINDICES;
//  float3 Normal: NORMAL;
//    float2 TexCoord:TEXCOORD0;    
//};
//
//struct vpconn  {
//  float4 HPosition: POSITION;
//  float2 TexCoord: TEXCOORD0;
//  float4 Color: COLOR0;
//};
//
//
//vpconn main(appdata IN,
//      uniform float4x4 WorldViewProj: register (c0),
//      uniform float3 LightVec: register (c4),
//      uniform float4 Diffuse: register (c5),
//      uniform float4 Ambient: register (c6),
//      uniform float3x4 Bones[MAXBONES]: register (c7)
//      )
//{
//  vpconn OUT;
//  
//  float4 tempPos;
//  tempPos.xyz = IN.Position.xyz;
//  tempPos.w = 1.0;
//  
//  float3 pos= 0;
//  float3 normal= 0;
//  
//  float4 i;
//  
//  i = IN.Indices;
//  
//  pos  = mul(Bones[i.x], tempPos) * IN.Weight.x;
//  pos += mul(Bones[i.y], tempPos) * IN.Weight.y;
//  pos += mul(Bones[i.z], tempPos) * IN.Weight.z;
//  pos += mul(Bones[i.w], tempPos) * IN.Weight.w;
//  
//  float3x3 m;
//  
//  m[0].xyz = Bones[i.x][0].xyz;
//  m[1].xyz = Bones[i.x][1].xyz;
//  m[2].xyz = Bones[i.x][2].xyz;
//     
//  normal += mul(m, IN.Normal)* IN.Weight.x;
//  
//  
//  m[0].xyz = Bones[i.y][0].xyz;
//  m[1].xyz = Bones[i.y][1].xyz;
//  m[2].xyz = Bones[i.y][2].xyz;
//     
//  normal += normalize(mul(m, IN.Normal)* IN.Weight.y);    
//  
//  normal = normalize(normal);
//  
//  OUT.Color.xyzw = (max(dot(normal, LightVec),0).xxxx+Ambient)*Diffuse;
//  
//  OUT.TexCoord.xy = IN.TexCoord.xy;
//  
//  float4 tempPos2;
//  
//  tempPos2.xyz = pos.xyz;
//  tempPos2.w = 1.0;
//  
//  OUT.HPosition = mul(WorldViewProj, tempPos2);
//  
//  return OUT;
//}
