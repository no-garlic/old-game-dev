// ----------------------------------------------------------------------------
// File: AnimationUtils.cs
// Desc: Utilities for animation playback
// Auth: Michael Petrou
// (C) Copyright: 2008
// ----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

using SkinnedModel;


namespace WaveRace360
{
  // --------------------------------------------------------------------------
  // Name: AnimationBlender
  // Desc: Utilities for animation playback
  // --------------------------------------------------------------------------
  public class AnimationUtils
  {
    // ------------------------------------------------------------------------
    // Name: Blend
    // Desc: Blend between the surrounding keyframes to set the animation pose 
    //       at the given time.
    // Parm: IList<AnimationFrame> a_frames - the animation frames
    // Parm: float a_time - the time for the pose
    // Parm: Vector3[] a_translation - the output translation data
    // Parm: Quaternion[] a_rotation - the output rotation data
    // ------------------------------------------------------------------------
    static public void Blend(IList<AnimationFrame> a_frames, float a_time, Vector3[] a_translation, Quaternion[] a_rotation)
    {
      AnimationFrame frameA = null;
      AnimationFrame frameB = null;

      foreach(AnimationFrame animationFrame in a_frames)
      {
        // Get this frame and last frame pointers
        frameA = frameB;
        frameB = animationFrame;

        // Skip the first loop iteration
        if (frameA == null)
        {
          continue;
        }

        // Get the time at A and B
        float tA = (float) frameA.Time.TotalSeconds;
        float tB = (float) frameB.Time.TotalSeconds;

        // Is a_time between frameA and frameB (inclusive)
        if (tA <= a_time && tB >= a_time)
        {
          // Get the duration of the keyframe
          float d = tB - tA;

          // Get the progress (in time) that a_tim is between A and B.
          float p = a_time - tA;

          // Calculate the progress as a factor of the duration
          float f = p / d;

          // Process all keyframes (one for each bone).
          for (int i = 0; i < frameA.Keyframes.Count; i++)
          {
            // Get the keyframes at either side of a_time
            Keyframe kfA = frameA.Keyframes[i];
            Keyframe kfB = frameB.Keyframes[i];

            // Quick check that the bones match - unless there is a bug in the pipeline this should be ok
            if (kfA.Bone != kfB.Bone)
            {
              throw new ArgumentException("kfA.Bone != kfB.Bone");
            }

            // Get the bone
            int bone = kfA.Bone;

            // Interpolate between the keys
            a_translation[bone] = Vector3.Lerp(kfA.Translation, kfB.Translation, f);
            a_rotation[bone] = Quaternion.Slerp(kfA.Rotation, kfB.Rotation, f);
          }
        }
      }
    }

    
    // ------------------------------------------------------------------------
    // Name: AnimationBlendBuffer
    // Desc: A blend buffer for blending multiple animations across multiple 
    //       bones
    // ------------------------------------------------------------------------
    public class AnimationBlendBuffer
    {
      // ----------------------------------------------------------------------
      // Name: class 
      // Desc: A buffer for blending multiple keyframes on the same bone, from 
      //       different animations
      // ----------------------------------------------------------------------
      private class BoneBuffer
      {
        // --------------------------------------------------------------------
        // Name: Entry
        // Desc: A structure for storing data for a single bone keyframe
        // --------------------------------------------------------------------
        public class Entry
        {
          public Vector3      m_translation;  // The bone translation
          public Quaternion   m_rotation;     // The bone rotation
          public float        m_influence;    // The influence
        }

        // --------------------------------------------------------------------
        // Private members
        // --------------------------------------------------------------------
        public SortedList<float, Entry>   m_entries;      // All entries for this bone
        public Vector3                    m_translation;  // The translation generated by blending all entries
        public Quaternion                 m_rotation;     // The rotation generated by blending all entries

        // --------------------------------------------------------------------
        // Name: BoneBuffer
        // Desc: Constructor
        // --------------------------------------------------------------------
        public BoneBuffer()
        {
          m_entries = new SortedList<float, Entry>();
          m_translation = new Vector3();
          m_rotation = new Quaternion();
        }

        // --------------------------------------------------------------------
        // Name: Add
        // Desc: Add a keyframe for this bone
        // Parm: Vector3 a_translation - the translation
        // Parm: Quaternion a_rotation - the rotation
        // Parm: float a_influence - the influence
        // --------------------------------------------------------------------
        public void Add(Vector3 a_translation, Quaternion a_rotation, float a_influence)
        {
          // Create the storage structure
          Entry e = new Entry();

          // Assign the values
          e.m_translation = a_translation;
          e.m_rotation = a_rotation;
          e.m_influence = a_influence;

          // Generate a unique key based on the influence (for sorting)
          float key = 1.0f - a_influence;
          while (m_entries.ContainsKey(key))
          {
            if (key <= 0.0f)
            {
              key = key + 0.00017584f;
            }
            else
            {
              key = key - 0.00001398f;
            }
          }

          // Add the entry
          m_entries.Add(key, e);
        }


        // --------------------------------------------------------------------
        // Name: Blend
        // Desc: Blend all keys for this bone
        // --------------------------------------------------------------------
        public void Blend()
        {
          m_translation = Vector3.Zero;
          m_rotation = Quaternion.Identity;

          for (int i = 0; i < m_entries.Values.Count; i++)
          {
            Entry e = m_entries.Values[i];

            if (i == 0)
            {
              m_translation = e.m_translation * e.m_influence;
              m_rotation = e.m_rotation;
            }
            else
            {
              m_translation += (e.m_translation * e.m_influence);
              m_rotation = Quaternion.Slerp(m_rotation, e.m_rotation, e.m_influence);
            }
          }
        }        
      }


      // ----------------------------------------------------------------------
      // Private members
      // ----------------------------------------------------------------------
      private BoneBuffer[]  m_boneBuffers;  // BoneBuffer objects, one for each bone
      private int           m_boneCount;    // Number of bones


      // ----------------------------------------------------------------------
      // Name: AnimationBlendBuffer
      // Desc: Constructor
      // Parm: int a_boneCount - the number of bones
      // ----------------------------------------------------------------------
      public AnimationBlendBuffer(int a_boneCount)
      {
        m_boneCount = a_boneCount;
        m_boneBuffers = new BoneBuffer[m_boneCount];

        for (int i = 0; i < m_boneCount; i++)
        {
          m_boneBuffers[i] = new BoneBuffer();
        }
      }


      // ----------------------------------------------------------------------
      // Name: Add
      // Desc: Add a keyframe
      // Parm: int a_bone       - the bone
      // Parm: Vector3 a_translation - the translation
      // Parm: Quaternion a_rotation - the rotation
      // Parm: float a_influence - the influence
      // ----------------------------------------------------------------------
      public void Add(int a_bone, Vector3 a_translation, Quaternion a_rotation, float a_influence)
      {
        m_boneBuffers[a_bone].Add(a_translation, a_rotation, a_influence);
      }


      // ----------------------------------------------------------------------
      // Name: Blend
      // Desc: Blend all keyframes on all bones
      // ----------------------------------------------------------------------
      public void Blend()
      {
        foreach (BoneBuffer boneBuffer in m_boneBuffers)
        {
          boneBuffer.Blend();
        }
      }


      // ----------------------------------------------------------------------
      // Name: GetKey
      // Desc: Get the blended values
      // Parm: int a_bone           - the bone to get the blended values for
      // Parm: out Vector3 a_translation - [out] the translation
      // Parm: out Quaternion a_rotation - [out] the rotation
      // ----------------------------------------------------------------------
      public void GetKey(int a_bone, out Vector3 a_translation, out Quaternion a_rotation)
      {
        BoneBuffer boneBuffer = m_boneBuffers[a_bone];

        a_translation = boneBuffer.m_translation;
        a_rotation = boneBuffer.m_rotation;
      }
    }

  
  }
}


// -- EOF



