<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)http://ggt.sourceforge.net/html/gmtlfaq.html -->
<HTML><HEAD><TITLE>Generic Math Template Library FAQ</TITLE>
<META http-equiv=Content-Type content=text/html;charset=iso-8859-1><LINK 
href="Generic Math Template Library FAQ_files/doxygen.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY><!-- Generated by Doxygen 1.2.14 -->
<CENTER><A class=qindex href="http://ggt.sourceforge.net/html/main.html">Main 
Page</A> &nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/modules.html">Modules</A> &nbsp; <A 
class=qindex href="http://ggt.sourceforge.net/html/namespaces.html">Namespace 
List</A> &nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/hierarchy.html">Class Hierarchy</A> &nbsp; 
<A class=qindex href="http://ggt.sourceforge.net/html/classes.html">Alphabetical 
List</A> &nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/annotated.html">Compound List</A> &nbsp; 
<A class=qindex href="http://ggt.sourceforge.net/html/files.html">File List</A> 
&nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/namespacemembers.html">Namespace 
Members</A> &nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/functions.html">Compound Members</A> 
&nbsp; <A class=qindex href="http://ggt.sourceforge.net/html/globals.html">File 
Members</A> &nbsp; <A class=qindex 
href="http://ggt.sourceforge.net/html/pages.html">Related Pages</A> &nbsp; 
</CENTER>
<HR>
<A name=gmtlfaq>
<H2>Generic Math Template Library FAQ</H2></A>Welcome to the GMTL frequently 
asked questions list. 
<P><A name=faqgeneral>
<H2>General Questions about GMTL</H2></A>
<P><A name=faqwhytemplates>
<H3>Why do you use templated code?</H3></A>
<P>There are several benefits to using the templated code approach. First, it 
allows us to easily support multiple versions of very similar data types. For 
instance, there are many different types of matrices, varying in both size and 
data type. We could have 4x4 floating point, 3x3 double precision, 2x2 floating 
point, etcetera. These are very different matrices, but in general they all 
support the same kinds of operations. With templated code, we can write a single 
function in many cases that will handle all possible variations of a GMTL 
object. 
<P>Templated code also makes GMTL very easy to extend. Although GMTL provides 
many data types to begin with, it allows a lot of flexibility for developers to 
customize their own code. For instance, GMTL provides several commonly-used 
vector types such as 2, 3, and 4-dimensional floating point vectors. But maybe 
you're a physicist doing research in the 6th dimension, and you need a 6-D 
vector. GMTL's templated code allows you to create a vector of arbitrary 
dimensionality. And the vector's math operations are written in such a way that 
they will work for vectors of any size, eliminating the need for the physicist 
to rewrite all of the vector math. 
<P>It also allows us to provide a unified interface to GMTL objects. This is why 
many of the functions in GMTL have the same name, but can work on a wide variety 
of data types. Developers using GMTL have much less to remember than if we had a 
separate function name for each possible combination of data types. Instead, 
functions that conceptually do a similar function have many versions overloaded 
with different data type combinations. 
<P><B>What's with these namespaces?</B> 
<P>All of GMTL's functions and data types are defined within the '<A class=el 
href="http://ggt.sourceforge.net/html/namespacegmtl.html">gmtl</A>' namespace. 
<P>In C++, you can reference something in a namespace by prepending it to the 
thing you want to reference. For instance, when creating any GMTL object, you 
need to prepend "<A class=el 
href="http://ggt.sourceforge.net/html/namespacegmtl.html">gmtl</A>::" to its 
name. The following code shows the instantiation of several different objects. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMatrix;
  gmtl::Vec3f myVector;
  gmtl::Quatf myQuaternion;
</PRE></DIV>
<P>Similarly, GMTL's function calls also need to have this namespace: 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a0">gmtl::identity</A>( myMatrix );
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a47">gmtl::normalize</A>( myVector );
</PRE></DIV>
<P>Developers can also specify that they are using a particular namespace in 
their code, aleviating the need to specify the namespace for each object. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keyword>using</FONT> <FONT class=keyword>namespace </FONT>gmtl
  {
      <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a66">Matrix44f</A> myMatrix;
      <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a102">Vec3f</A> myVector;
      <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a47">normalize</A>( myVector );
  };
</PRE></DIV>
<P>Additionally, GMTL's C math functions are further encapsulated by a namespace 
called "Math". To reference these functions, you must prepend "<A class=el 
href="http://ggt.sourceforge.net/html/namespacegmtl_1_1Math.html">gmtl::Math</A>::" 
to the function names. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> cosine = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl_1_1Math.html#a22">gmtl::Math::cos</A>( 3.14 );
  <FONT class=keywordtype>float</FONT> minimum = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl_1_1Math.html#a52">gmtl::Math::Min</A>( 3.0, 1.4, -43.2 );
</PRE></DIV>
<P><B>Why would I want to use GMTL's C math abstraction rather than the regular 
C math library?</B> 
<P>GMTL has abstracted the C math libraries to ensure cross-platform 
compatibility. If you write an application using GMTL's math functions, you do 
not have to make any changes when building on different platforms. 
<P>The math abstraction is also designed to be type safe. It will work for 
different mathematical data types such as float and double without having 
different function syntax for each data type. For instance, on some platforms, 
the math library is designed solely for double-precision floating point numbers 
and separate functions are provided for regular float numbers, with an 'f' 
appended to each function name. On such platforms, you have math functions like 
'floor' &amp; 'floorf' as well as 'cos' and 'cosf'. 
<P>In GMTL, there is only one function name to remember for each type of 
operation, regardless of the data type. So you could pass either a double or a 
float to GMTL's 'cos' function to get the cosine value. 
<P><B>What is an AABox?</B> 
<P>This is an axially-aligned bounding box. Think of it as a box in 3D space 
with its each of its sides parallel to one of the coordinate axes. Such a box 
can be described using only 2 points, the minimum and maximum. AABoxes can be 
useful in object collision detection. 
<P><B>What is an AxisAngle?</B> 
<P>This is a rotational data type, defined by an arbitrary axis vector in space 
and an amount of rotation. 
<P><B>What is a Coord?</B> 
<P>This is a coordinate frame, defined by a position and a rotation value. 
<P><B>What is an EulerAngle?</B> 
<P>This is a data type that represents a rotational value. It consists of three 
values, each representing a rotation about one of the coordinate axes X, Y, and 
Z. Note that Euler angle representations are often more intuitive to use, but 
suffer from the problem of Gimble lock. 
<P><B>What is a LineSeg?</B> 
<P>This is a line segment of finite length. It consists of 2 endpoints in space. 
Internally to GMTL, a LineSeg is defined by an endpoint in space and a vector 
that shows where the other endpoint is relative to the first point. 
<P><B>What is a Matrix?</B> 
<P>This is a data type commonly used in graphical applications. It simply 
contains rows and columns of data, with any number of rows and columns. 4x4 
matrices can represent any transformation in 3D space, containing (but not 
limited to) translational, rotational, skew, and scaling information. 
<P><B>What is a Plane?</B> 
<P>A plane is a flat surface in 3D space with no boundaries. It is defined by a 
point in 3D space and a surface normal vector. 
<P><B>What is a Point?</B> 
<P>Points represent a position in space, with one data value per dimension of 
that space. 
<P><B>What is a Quat?</B> 
<P>This is a quaternion, which is represents a rotation in 3D space. Quaternions 
can be used for rotational interpolation along the surface of a sphere. They are 
represented at a 4-element normalized vector. 
<P><B>What is a Ray?</B> 
<P>A ray is a line in space that has an origin point extends to infinity in some 
direction. In GMTL, a ray is represented by a Point object denoting its origin 
and a vector showing the direction it is pointing. 
<P><B>What is a Sphere?</B> 
<P>This is a 3D dimensional round object such that every point on the outer 
boundary of the object is the same distance away from the centerpoint. A sphere 
can be described by a centerpoint position and a radius. 
<P><B>What is a Tri?</B> 
<P>This is a triangle, defined by three points in space. The counterclockwise 
ordering of the points determines the direction of the triangle's surface normal 
(using a right-handed coordinate system). 
<P><B>What is a Vec?</B> 
<P>This is a vector that represents a direction in space, with one data value 
per dimension of the space. 
<P><B>What is the difference between a point and a vector?</B> 
<P>Points represent positions in space, while vectors represent a direction. 
Even though they may seem to represent the same data, it is generally 
discouraged to use them interchangably. Differences occur when operations are 
performed on them. For instance, if you transform a point using a matrix, the 
full transformation will be applied to the point (translation, rotation, skew, 
and scale). But when a vector is transformed by a matrix, only the rotational 
transform is applied to it. 
<P><B>Why doesn't my vector move?</B> 
<P>If you are transforming a vector using a matrix, only the matrix's rotational 
information will be applied. Hence, you may be expecting the vector's endpoint 
to change but it will not. You most likely want to use a Point object instead of 
a Vec. 
<P><B>What is the difference between AxisAngle, EulerAngle and Quat?</B> 
<P>An axis angle consists of a vector designating the axis to rotate about, and 
the rotation amount to use. An Euler angle object consists of 3 rotation 
amounts, one for each coordinate axis X, Y, and Z. Euler angles are often the 
most intuitive rotation type, but suffer from the Gimble lock problem. A 
quaternion has 4 values that can be translated into an axis and a rotation 
amount, but are stored in a normalized form that maintain the mathematical 
properties of quaternions, including the ability of spherical interpolation. 
<P><B>How is data represented in a matrix?</B> 
<P>GMTL matrices have their data stored in a 2-dimension natrix array in column 
major order. This means that you can access the data using the following syntax: 

<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <FONT class=keywordtype>int</FONT> row, column = 2;
  <FONT class=keywordtype>float</FONT> data = myMat[column][row];
</PRE></DIV>
<P>This representation is the same for many graphics API's, including OpenGL, 
DirectX, Performer, and OpenSG - each of which uses matrix data in a column 
major ordering. 
<P><B>What are the general concepts behind GMTL?</B> 
<P>This question is best answered by our "Light Overview of GMTL" in the online 
documentation of GMTL. It is located at the following webpage: <A 
href="http://ggt.sourceforge.net/html/main.html" 
target=top>http://ggt.sourceforge.net/html/main.html</A> 
<P><B>What's with all the 'make' and 'set' functions?</B> 
<P>In general, think of the make function as creating a new object based on an 
existing object, or extracting some part (or all) of an existing object. By 
comparison, use the set function to copy some part of one object to another 
existing object. 
<P>You use the 'make' function to generate new objects based on existing objects 
that may not even be the same type. For instance, we can create a quaternion 
rotation from an existing Euler angle rotation. Once made, the quaternion will 
perform the exact same rotation as the Euler angle. 
<P></P>
<DIV class=fragment><PRE>  gmtl::EulerAngleXYZf myEuler;
  gmtl::Quatf myQuat = gmtl::make&lt;gmtl::Quatf&gt;( myEuler );
</PRE></DIV>
<P>Note that you have to specify a templated argument that says what kind of 
object you want to be made. 
<P>Although you can usually make one object from any other type of object, there 
are some fundamental limitations. For instance, you can't make a quaternion 
(purely rotational information) from a vector (purely translational 
information), with the exception of using the makePure function (see below for 
details). Similarly, if you have a matrix containing both translational and 
rotational information, you can only make a vector based on the translational 
data. 
<P>In the following example, we make a new axis angle object that has the same 
rotational data as our existing matrix. Regardless of whatever translation and 
scaling data our matrix contains, only the rotation is represented in the new 
axis angle. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  gmtl::AxisAnglef myAA = gmtl::make&lt;gmtl::AxisAnglef&gt;( myMat );
</PRE></DIV>
<P>The 'set' function, however, modifies an existing object with data from 
another object. For instance, if you already have a quaternion and you want to 
change its rotation data to match an Euler angle, the 'set' function is 
appropriate. Note that the first argument is ALWAYS the object that you want to 
change, and the second argument is ALWAYS the object that you want to use as the 
data source. The source data will not be changed. 
<P></P>
<DIV class=fragment><PRE>  gmtl::EulerAngleXYZf myEuler;
  gmtl::Quatf myQuat;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a139">gmtl::set</A>( myQuat, myEuler );
</PRE></DIV>
<P><B>What are the makeTrans, makeRot, setTrans, setScale, etc. functions?</B> 
<P>These are altered versions of the 'make' and 'set' functions that 
specifically target certain types of data, such as rotational, translational, or 
scaling information. 
<P>Data types such as coordinate frame objects and matrices can have a 
combination of different types of transformations. For instance, a particular 
matrix could describe a translation and a rotation. But perhaps you only want to 
know the translation of it. In this case, the makeTrans function can be useful. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myFullMat;
  gmtl::Matrix44f myTransMat;

  myTransMat = gmtl::makeTrans&lt;gmtl::Matrix44f&gt;( myFullMat );
</PRE></DIV>
<P>Now 'myTransMat' represents the translational aspect of 'myFullMat'. If we 
had simply used the 'make' function instead of 'makeTrans', then myTransMat 
would be a complete copy of myFullMat. 
<P>As with the 'set' function, other functions like 'setTrans' or 'setRot' copy 
a feature from one object to another, with the objects not necessarily being the 
same type. The following example shows how to set the translation of a matrix 
from a coordinate frame object: 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  gmtl::CoordVec3EulerAngleXYZf myCoord;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a13">gmtl::setTrans</A>( myMat, myCoord );
</PRE></DIV>
<P>Note that whatever rotational data the matrix had is maintained even after 
using the setTrans function, which will only modify its translational aspect. 
<P>There are many altered 'make' and 'set' extensions beyond what we have 
discussed, but they all work in the same manner. Some commonly-used ones are 
makeTrans, setTrans, makeRot, setRot, makeScale, and setScale. Here are a few 
others that you might use: 
<P>The makeDirCos function creates a matrix or quaternion rotation using 
direction cosines. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f xDestAxis, yDestAxis, zDestAxis;
  gmtl::Vec3f xSrcAxis, ySrcAxis, zSrcAxis;

  gmtl::Matrix44f myMat = gmtl::makeDirCos&lt;gmtl::Matrix44f&gt;( xDestAxis, yDestAxis, zDestAxis, xSrcAxis, ySrcAxis, zSrcAxis );
</PRE></DIV>
<P>The makePure function allows you to start with a vector and create a 
quaternion with that vector as its rotation axis, but without any twist value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  gmtl::Quatf myQuat = gmtl::makePure&lt;gmtl::Quatf&gt;( myVec );
</PRE></DIV>
<P>You can use the makeVec function to extract the axis of rotation from a 
quaternion object. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf myQuat;
  gmtl::Vec3f myVec = gmtl::makeVec&lt;gmtl::Vec3f&gt;( myQuat );
</PRE></DIV>
<P>The makeNormal function allows you to create a normalized object from a 
source object. Usually this will deal with vectors. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f srcVec;
  gmtl::Vec3f normVec = gmtl::makeNormal&lt;gmtl::Vec3f&gt;( srcVec );
</PRE></DIV>
<P>The makeXRot, makeYRot, makeZRot functions can be used to extract rotational 
data about particular axes. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <FONT class=keywordtype>float</FONT> xrot = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a36">gmtl::makeXRot</A>( myMat );
</PRE></DIV>
<P><B>Why do we need all the extensions on the end of data types?</B> 
<P>This refers to the fact that you can use our provided type definitions to 
create specific versions of an object. For instance, there are many types of 
matrices, with varying numbers of rows and columns, as well as the kind of data 
contained therein. You can't simply make a Matrix, you must specify what kind: 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Matrix.html">gmtl::Matrix</A> myMatrix;      <FONT class=comment>//This will not work</FONT>
  gmtl::Matrix44f myMatrix;   <FONT class=comment>//This is correct</FONT>
</PRE></DIV>
<P>The reason we have these extensions (shown here by "44f" appended to the 
Matrix data type) is purely for simplicity. You can always create objects using 
templated arguments, but the extended versions of the data types are provided 
for convenience. As an example, we can create the 4x4 floating point matrix 
shown previously: 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMatrix;
  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Matrix.html">gmtl::Matrix&lt;float, 4, 4&gt;</A> myMatrix;
</PRE></DIV>
<P>These two instantiations of myMatrix are equivalent, but you can see how the 
first version can be much easier to read and write. If you want to get more 
serious about simplifying your code, you can create your own type definitions. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keyword>typedef</FONT> <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Matrix.html">gmtl::Matrix&lt;float, 4, 4&gt;</A> Mat;
  <FONT class=keyword>typedef</FONT> <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Vec.html">gmtl::Vec&lt;float, 3&gt;</A> Vector;
</PRE></DIV>
<P>These type definitions make the following pairs of object instantiations 
equivalent: 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Matrix.html">gmtl::Matrix&lt;float, 4, 4&gt;</A> myMatrix;
  Mat myMatrix;

  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Vec.html">gmtl::Vec&lt;float, 3&gt;</A> myVec;
  Vector myVec;
</PRE></DIV>
<P><A name=Spatial>
<H2>Spatial Objects</H2></A><B>What is a spatial object?</B> 
<P>A spatial object is something that has some sort of geometric meaning, rather 
than being purely mathematical. Spatial objects can be visualized in some way, 
such that you could draw them on a piece of paper or render them using 3-D 
graphics. They occupy some portion of an n-dimensional space, typically 2-D or 
3-D. 
<P>Spatial objects are typically used for generating boundaries or performing 
collision detection. They can be extremely useful in graphical applications. We 
can perform special operations on spatial objects, such as testing whether 
certain objects intersect with each other or whether one volumetric object (such 
as a sphere) contains another spatial object. 
<P><B>What kinds of spatial objects does GMTL support?</B> 
<P>Points, vectors, line segments, rays, planes, spheres, axially-aligned boxes, 
and triangles. 
<P><B>What objects in GMTL are not considered spatial?</B> 
<P>Matrices, quaternions, axis angles, Euler angles, and coordinate frames. 
<P><A name=Howto>
<H2>How Do I ...?</H2></A>
<P><A name=Vectors>
<H3>Vectors</H3></A><B>How do I rotate a vector?</B> 
<P>In most cases you can simply use the * operator with your vector and one of 
the rotaional data types. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1AxisAngle.html">gmtl::AxisAngle</A> myAA;
  gmtl::Quaternion myQuat;
  gmtl::Matrix44f myMat;
  gmtl::EulerAngleXYZf myEuler;
 
  myVec = myVec * myAA;
  myVec = myVec * myQuat;
  myVec = myVec * myMat;
  myVec = myVec * myEuler;
</PRE></DIV>
<P><B>How do I find the cross product of 2 vectors?</B> 
<P>We can use the cross function, which returns another vector. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f vecA, vecB, crossVec;
  crossVec = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a69">gmtl::cross</A>( vecA, vecB );
</PRE></DIV>
<P><B>How do I find the dot product of 2 vectors?</B> 
<P>Use the dot function, which returns a number (depending on the type of data 
in the vectors). 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3d vecA, vecB;
  <FONT class=keywordtype>double</FONT> x = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a44">gmtl::dot</A>( vecA, vecB );
</PRE></DIV>
<P><B>How do I check if a vector is normalized?</B> 
<P>Use the isNormalized function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a48">gmtl::isNormalized</A>( myVec ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Vector is normalized"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I normalize a vector?</B> 
<P>Use the normalize function. After this, the length of the vector will be 1, 
unless the original length was 0, in which case normalization is not possible. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a47">gmtl::normalize</A>( myVec );
</PRE></DIV>
<P><B>How do I check if 2 vectors are equal?</B> 
<P>Use the == operator, just as you would when testing the equality of simple 
data types like `int'. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f vecA, vecB;
  <FONT class=keywordflow>if</FONT> ( vecA == vecB )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Vectors are equal"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I find the length of a vector?</B> 
<P>Use the length function. The numeric type returned depends on the data type 
of the vector. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  <FONT class=keywordtype>float</FONT> length = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a46">gmtl::length</A>( myVec );
</PRE></DIV>
<P>Another potential function to use is lengthSquared. This function is provided 
as a convenience because GMTL users frequently need this value rather than 
merely the length. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> lengthSq = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a45">gmtl::lengthSquared</A>( myVec );
</PRE></DIV>
<P><B>How do I invert a vector?</B> 
<P>Use A scalar multiplication by -1. This will cause the vector to be pointing 
in the exact opposite direction and keep the same length. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  myVec *= -1;
</PRE></DIV>
<P><B>How do I interpolate between 2 vectors?</B> 
<P>Use the lerp function. This will perform a linearly-interpolated vector based 
on 2 original vectors and an interpolation weight between 0 and 1. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f resultVec, vecA. vecB;
  <FONT class=keywordtype>float</FONT> weight = 0.333;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a3">gmtl::lerp</A>( resultVec, weight, vecA, vecB );
</PRE></DIV>
<P>After this function, resultVec now contains a vector that is one third of the 
way from vecA to vecB. This resulting vector is closer to vecA. 
<P><B>How do I multiply a vector by a scalar value?</B> 
<P>Simply use the * or *= operator. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec, anotherVec;
  <FONT class=keywordtype>float</FONT> myScalar = 3.5;

  myVec *= myScalar;
  anotherVec = myVec * myScalar;
</PRE></DIV>
<P><B>How do I add, subtract, divide and multiply vectors?</B> 
<P>Generally, you can use any of the standard mathematical operators ('+', '-', 
'*', '/') to perform math functions on vectors. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f vecA, vecB, vecC;

  vecA = vecB * vecC;
  vecA = vecB / vecC;
  vecA += vecB;
  vecA = vecB + vecC;
  vecA -= vecC;
  vecA = vecB - vecC;
</PRE></DIV>
<P>etc. 
<P><A name=Matrices>
<H3>Matrices</H3></A><B>How do I multiply matrices?</B> 
<P>The simplest way to multiply one matrix by another is to use the * operator. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f A, B, C;
  A = B * C;
</PRE></DIV>
<P>Note that when multiplying matrices, the ordering matters. The following line 
of code could make matrix A have a different result: 
<P></P>
<DIV class=fragment><PRE>  A = C * B;
</PRE></DIV>
<P>Alternatively, you can use the preMult and postMult functions. 
<P>This preMult call is the same as "A = B * A;" 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a12">gmtl::preMult</A>( A, B ); 
</PRE></DIV>
<P>This postMult call is the same as "A = A * B;" 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a11">gmtl::postMult</A>( A, B );
</PRE></DIV>
<P>The *= operator also acts as a postMult function. 
<P></P>
<DIV class=fragment><PRE>  A *= B;
</PRE></DIV>
<P><B>How do I create a matrix?</B> 
<P>You can create a new matrix simply by instantiating it. You can use one of 
the GMTL-provided type definitions. The first matrix is a 4x4 matrix of floating 
point numbers. The second is a 2x3 matrix of double precision floating point 
numbers. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  gmtl::Matrix23d otherMat;
</PRE></DIV>
<P>You can also create matrices of arbitrary size and data type using the 
templated constructor. The templated arguments are (in order) the data type, the 
number of rows, and the number of columns. For example, the following creates a 
4x6 matrix of floating point numbers. 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1Matrix.html">gmtl::Matrix&lt; float, 4, 6 &gt;</A> newMatrix;
</PRE></DIV>
<P>You can also create a matrix from any of the other transformation data types. 
See below for examples. 
<P><B>How do I create a matrix from a vector?</B> 
<P>Using the makeTrans function, you can create a purely translational matrix 
from a vector. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  gmtl::Matrix44f myMat = gmtl::makeTrans&lt; gmtl::Matrix44f &gt;( myVec );
</PRE></DIV>
<P><B>How do I create a matrix from a point?</B> 
<P>Using the make function, you can create a purely translational matrix from a 
point. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Point3f myPoint;
  gmtl::Matrix44f myMat = gmtl::make&lt; gmtl::Matrix44f &gt;( myPoint );
</PRE></DIV>
<P><B>How do I create a matrix from a quaterion?</B> 
<P>Using the make function, you can create a purely rotational matrix from a 
quaternion object. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf myQuat;
  gmtl::Matrix44f myMat = gmtl::make&lt; gmtl::Matrix44f &gt;( myQuat );
</PRE></DIV>
<P><B>How do I create a matrix from an Euler angle?</B> 
<P>Using the make function, you can create a purely rotational matrix from an 
EulerAngle object. 
<P></P>
<DIV class=fragment><PRE>  gmtl::EulerAngleXYZf myEulerAngle;
  gmtl::Matrix44f myMat = gmtl::make&lt; gmtl::Matrix44f &gt;( myEulerAngle );
</PRE></DIV>
<P><B>How do I create a matrix from an axis angle?</B> 
<P>Using the make function, you can create a purely rotational matrix from an 
AxisAngle object. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AxisAnglef myAxisAngle;
  gmtl::Matrix44f myMat = gmtl::make&lt; gmtl::Matrix44f &gt;( myAxisAngle );
</PRE></DIV>
<P><B>How do I scale a matrix?</B> 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <FONT class=keywordtype>float</FONT> scale = 0.5;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a27">gmtl::setScale</A>( myMat, scale );
</PRE></DIV>
<P><B>How do I copy a matrix?</B> 
<P>You can simply use the '=' operator to copy from one matrix to another. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f matA, matB;
  matA = matB;
</PRE></DIV>
<P><B>How do I access individual data elements of a matrix?</B> 
<P>You can simply use the [ row# ][ column# ] operators, just as you would if 
you were accessing elements of a double array. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <FONT class=keywordtype>float</FONT> x = myMat[3][2];
</PRE></DIV>
<P><B>How do I extract just the rotation data from a matrix?</B> 
<P>You can extract the rotational data as any of GMTL's rotation data types. In 
any case, you need to use the makeRot templated function. Note that you need to 
specify which rotation data type you want to extract. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  gmtl::EulerAngleXYZf myEuler;
  gmtl::AxisAnglef myAxisAngle;
  gmtl::Quatf myQuat;
  gmtl::Matrix44f myRotationMat;

  myEuler = gmtl::makeRot&lt; gmtl::EulerAngleXYZf &gt;( myMat );
  myAxisAngle = gmtl::makeRot&lt; gmtl::AxisAnglef &gt;( myMat );
  myQuat = gmtl::makeRot&lt; gmtl::Quatf &gt;( myMat );
  myRotationMat = gmtl::makeRot&lt; gmtl::EulerAngleXYZf &gt;( myMat );
</PRE></DIV>
<P><B>How do I extract just the translation data from a matrix?</B> 
<P>You can extract the translational data as either a vector or a point. You 
need to use the templated makeTrans function. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  gmtl::Point3f myPoint;
  gmtl::Vec3f myVec;
 
  myVec = gmtl::makeTrans&lt; gmtl::Vec3f &gt;( myMat );
  myPoint = gmtl::makeTrans&lt; gmtl::Point3f &gt;( myMat );
</PRE></DIV>
<P><B>How do I set a matrix to be the identity matrix?</B> 
<P>Matrices will automatically be identity matrices upon creation. If you want 
to set them to the identity later, use the identity function. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a0">gmtl::identity</A>( myMat );
</PRE></DIV>
<P><B>How do I set a matrix to contain all zeros?</B> 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a6">gmtl::zero</A>( myMat );
</PRE></DIV>
<P><B>How do I invert a matrix?</B> 
<P>In most cases you can simply use the invert function. This will perform a 
"smart" inversion that selects an inversion method (full, affine, orthonormal, 
orthogonal, or identity) based on the kinds of transformations it has been 
through. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a20">gmtl::invert</A>( myMat );
</PRE></DIV>
<P>You can optionally force a full inversion by using the invertFull function. 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a19">gmtl::invertFull</A>( myMat );
</PRE></DIV>
<P><B>How do I transpose a matrix?</B> 
<P>Use the transpose function. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a17">gmtl::transpose</A>( myMat );
</PRE></DIV>
<P><B>How do I transform a point using a matrix?</B> 
<P>This will perform a full transformation on the point. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Point3f myPoint;
  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a0">gmtl::xform</A>( myPoint, myMat, myPoint );
</PRE></DIV>
<P><B>How do I transform a vector using a matrix?</B> 
<P>It is important to note that a vector will only be modified by the rotational 
transformation contained in a matrix. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f myVec;
  gmtl::Matrix44f myMat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a0">gmtl::xform</A>( myVec, myMat, myVec ); 
</PRE></DIV>
<P><B>How do I use my matrix data with OpenGL?</B> 
<P>You can access the raw matrix data for use with OpenGL using the getData() 
function. For instance, you may want to multiply the OpenGL matrix stack by a 
GMTL matrix. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Matrix44f myMat;
  glMultMatrixf( myMat.getData() );
</PRE></DIV>
<P>Note that GMTL matrix data is also safe to use for other graphics APIs such 
as DirectX, Performer, and OpenSG. 
<P><A name=Quaternions>
<H3>Quaternions</H3></A><B>How do I create quaternions?</B> 
<P>You can create quaternions directly using known values. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> x = 1.0;
  <FONT class=keywordtype>float</FONT> y, z, w = 0.0;
  gmtl::Quatf myQuat(x, y, z, w);
</PRE></DIV>
<P>You can also create quaternions based on other rotational types, such as an 
EulerAngle or matrix. 
<P></P>
<DIV class=fragment><PRE>  gmtl::EulerAngleXYZf myEuler;
  gmtl::Matrix44f myMat;
  myQuat = gmtl::make&lt;gmtl::Quatf&gt;( myEuler );
  myQuat = gmtl::make&lt;gmtl::Quatf&gt;( myMat );
</PRE></DIV>
<P><B>How do I multiply quaternions?</B> 
<P>Simply use the * and *= operators. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf quatA, quatB, quatC;
  quatA *= quatB;
  quatC = quatA * quatB;
</PRE></DIV>
<P><B>How do I combine quaternion rotations?</B> 
<P>This is the same as multiplying quaternions. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf quatA, quatB, quatC;
  quatA *= quatB;
  quatC = quatA * quatB;
</PRE></DIV>
<P><B>How do I perform spherical interpolation with quaternions?</B> 
<P>Use the slerp function. You need an origin quaternion, a target quaternion, 
and an interpolation amount between 0 and 1. The following example interpolated 
halfway between the origin and target quaternions. Note that the interpolation 
path follows the shortest length arc around a sphere. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf resultQuat, originQuat, targetQuat;
  <FONT class=keywordtype>float</FONT> amount = 0.5;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a1">gmtl::slerp</A>( resultQuat, amount, originQuat, targetQuat );
</PRE></DIV>
<P><B>How do I perform linear interpolation with quaternions?</B> 
<P>This is similar to performing spherical interpolation, but follows a straight 
line interpolation path rather than a shortest arc around a sphere. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf resultQuat, originQuat, targetQuat;
  <FONT class=keywordtype>float</FONT> amount = 0.5;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a3">gmtl::lerp</A>( resultQuat, amount, originQuat, targetQuat );
</PRE></DIV>
<P><B>How do I make a quaternion that rotates one vector to another along the 
shortest arc?</B> 
<P>If you have an origin vector and a target vector, you can use the makeRot 
function. Note that you should normalize these vectors first. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Vec3f originVec, targetVec;
  gmtl::Quatf myQuat;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a47">gmtl::normalize</A>( originVec );
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a47">gmtl::normalize</A>( targetVec );
  myQuat = gmtl::makeRot&lt;gmtl::Quatf&gt;( originVec, targetVec );
</PRE></DIV>
<P><B>How do I invert a quaternion?</B> 
<P>Use the invert function. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf myQuat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a20">gmtl::invert</A>( myQuat );
</PRE></DIV>
<P><B>How do I conjugate a quaternion?</B> 
<P>Use the conj function. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf myQuat;
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a49">gmtl::conj</A>( myQuat );
</PRE></DIV>
<P><B>How do I check if 2 quaternions are the same?</B> 
<P>Use the == and != operators. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Quatf quatA, quatB;
  <FONT class=keywordflow>if</FONT> (quatA == quatB)
  {
     cout &lt;&lt; <FONT class=stringliteral>"Quaternions are equal"</FONT> &lt;&lt; endl;
  }
  <FONT class=keywordflow>if</FONT> (quatA != quatB)
  {
     cout &lt;&lt; <FONT class=stringliteral>"Quaternions are not equal"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><A name=Collision>
<H3>Collision and Containment Detection</H3></A>
<P><B>How do I perform collision detection and containment tests?</B> 
<P>GMTL provides various spatial objects, including spheres, line segments, 
rays, points, triangles, planes, axially-aligned bounding boxes, and oriented 
bounding boxes. 
<P>The library also provides functions to test whether particular objects are 
intersecting each other or whether one object is contained by another. See below 
for specific examples. 
<P>In general, you can use the 'intersect' function on any two spatial objects 
to test whether they intersect with each other or not. And you can use the 
'isInVolume' to tell whether one volumetric object (such as a sphere or box) 
contains some other spatial object. 
<P><B>How do I test if a point is contained by a sphere?</B> 
<P>Use the isInVolume function, which returns a boolean value. Note that if the 
point is on the outer boundary of the sphere, it is still considered to be 
contained. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Point3f myPoint;
  gmtl::Spheref mySphere;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a115">gmtl::isInVolume</A>( mySphere, myPoint ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Point is inside the sphere"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if a point is on the surface of a sphere?</B> 
<P>Use the isOnVolume function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Point3f myPoint;
  gmtl::Spheref mySphere;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a120">gmtl::isOnVolume</A>( mySphere, myPoint ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Point is on the sphere"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P>You can optionally supply a tolerance argument, which will change the 
function to compute whether the point is within a certain distance of the 
sphere's surface. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> tolerance = 0.001;
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a120">gmtl::isOnVolume</A>( mySphere, myPoint, tolerance ))
  {
    cout &lt;&lt; <FONT class=stringliteral>"Point is on the sphere"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if one sphere is contained by another?</B> 
<P>Use the isInVolume function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Spheref sphereA, sphereB;
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a115">gmtl::isInVolume</A>( sphereA, sphereB ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Sphere is within the other sphere"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if two spheres intersect while moving?</B> 
<P>We can use the intersect function to compute this. We need a vector for each 
sphere representing the sphere's movement over the timestep. You also pass by 
reference 2 floating point numbers that will be modified by the function. The 
first of these numbers will be the normalized time of contact. The second is the 
normalized time of disconnection. The second number will only be set when the 
spheres pass through each other, in which case it will be set to the time when 
they stop intersecting. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Spheref sphereA, sphereB;
  gmtl::Vec3f pathA, pathB;
  <FONT class=keywordtype>float</FONT> contactTime, disconnectTime;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a190">gmtl::intersect</A>( sphereA, sphereB, pathA, pathB, contactTime, disconnectTime ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Spheres intersect at some time"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I change a sphere so that it contains a given point?</B> 
<P>Use the extendVolume function. This will keep the sphere's centerpoint in the 
same location, but extend its radius just enough to contain the given point. If 
the point is already inside the sphere, no change occurs. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Spheref mySphere;
  gmtl::Point3f myPoint;
 
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( mySphere, myPoint );
</PRE></DIV>
<P><B>How do I change a sphere so that it contains a set of points?</B> 
<P>There is a version of the extendVolume function that takes a STL vector 
containing an arbitrary number of points and will increase a sphere's radius to 
be just large enough to contain all of these points. If the sphere already 
contains all of the points, then the sphere will be unchanged. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Spheref mySphere;
  std::vector&lt;gmtl::Point3f&gt; myPoints;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( mySphere, myPoints );
</PRE></DIV>
<P><B>How do I change a sphere so that it contains another sphere?</B> 
<P>Use the extendVolume function. The first sphere's radius will be increased to 
be just large enough to contain the other sphere. If the first sphere already 
contains the other sphere, no change occurs. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Spheref sphereA, sphereB;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( sphereA, sphereB );
</PRE></DIV>
<P><B>How do I test if two AABoxes intersect?</B> 
<P>Use the intersect function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf boxA, boxB;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a190">gmtl::intersect</A>( boxA, boxB ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Boxes intersect"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if an AABox is contained by another?</B> 
<P>Use the isInVolume function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf boxA, boxB;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a115">gmtl::isInVolume</A>( boxA, boxB ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"Box A contains box B"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if a point is inside an AABox?</B> 
<P>Use the isInVolume function, which returns a boolean value. Note that if the 
point is on the box's surface, it is still considered to be contained. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf myBox;
  gmtl::Point3f myPoint;
  
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a115">gmtl::isInVolume</A>( myBox, myPoint ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"The point is inside the box"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if two AABoxes intersect while moving?</B> 
<P>We can use the intersect function to compute this. We need a vector for each 
AABox representing the box's movement over the timestep. You also pass by 
reference 2 floating point numbers that will be modified by the function. The 
first of these numbers will be the normalized time of contact. The second is the 
normalized time of disconnection. The second number will only be set when the 
boxes pass through each other, in which case it will be set to the time when 
they stop intersecting. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf boxA, boxB;
  gmtl::Vec3f pathA, pathB;
  <FONT class=keywordtype>float</FONT> contactTime, disconnectTime;

  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a190">gmtl::intersect</A>( boxA, boxB, pathA, pathB, contactTime, disconnectTime ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"AABoxes intersect at some time"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I change an AABox so that it contains a given point?</B> 
<P>Use the extendVolume function. This will increase the size of one or more of 
the box's bounding faces. If the point is already inside the box, then no change 
occurs. 
<P></P>
<DIV class=fragment><PRE>  <A class=code href="http://ggt.sourceforge.net/html/classgmtl_1_1AABox.html">gmtl::AABox</A> myBox;
  gmtl::Point3f myPoint;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( myBox, myPoint );
</PRE></DIV>
<P><B>How do I change an AABox so that it contains another AABox?</B> 
<P>Use the extendVolume function. This will increase the size of one or more of 
the first box's bounding faces. If the other box is already inside the first 
box, then no change occurs. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf boxA, boxB;
  
  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( boxA, boxB );
</PRE></DIV>
<P><B>How do I change an AABox so that it contains a given sphere?</B> 
<P>Use the extendVolume function. This will increase the size of one or more of 
the box's bounding faces. If the sphere is already inside the box, then no 
change occurs. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf myBox;
  gmtl::Spheref mySphere;

  <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a117">gmtl::extendVolume</A>( myBox, mySphere );
</PRE></DIV>
<P><B>How do I test if a sphere intersects with an AABox?</B> 
<P>Use the intersect function, which returns a boolean value. 
<P></P>
<DIV class=fragment><PRE>  gmtl::AABoxf myBox;
  gmtl::Spheref mySphere;
 
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a190">gmtl::intersect</A>( myBox, mySphere ) 0
  {
     cout &lt;&lt; <FONT class=stringliteral>"Box and sphere intersect\n"</FONT> &lt;&lt; endl;
  }
</PRE></DIV>
<P><B>How do I test if a ray intersects with a plane?</B> 
<P>Use the intersect function, which returns a boolean value. You also must pass 
by reference a floating point value, which will be modified to be an indicator 
of the point in space where the ray intersects the plane. You can then compute 
the exact point of intersection. 
<P></P>
<DIV class=fragment><PRE>  gmtl::Planef myPlane;
  gmtl::Rayf myRay;
  <FONT class=keywordtype>float</FONT> isect;
  
  <FONT class=keywordflow>if</FONT> ( <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl.html#a190">gmtl::intersect</A>( myPlane, myRay, isect ) )
  {
     cout &lt;&lt; <FONT class=stringliteral>"The ray intersects the plane"</FONT> &lt;&lt; endl;
  }

  gmtl::Point3f intersectPoint = myRay.origin + mRay.dir * isect; 
</PRE></DIV>
<P><A name=General>
<H3>General Math</H3></A><B>How do I use GMTL's C math abstraction?</B> 
<P>In your application, you simply include the 
<P><B>What operations does GMTL's C math abstraction have?</B> 
<P>GMTL provides function calls for everything that the standard C math library 
has. But they are templated functions, so you don't have to worry about what 
data types you are providing for argments. 
<P><B>What about PI?</B> 
<P>There is a floating point value provided for the number Pi. You can reference 
it using '<A class=el 
href="http://ggt.sourceforge.net/html/group__Math.html#a0">gmtl::Math::PI</A>'. 
<P>There are also constants provided for Pi divided by 2 and Pi divided by 4, 
both of which are commonly used in graphical applications. These additional 
values can be referenced by '<A class=el 
href="http://ggt.sourceforge.net/html/group__Math.html#a59">gmtl::Math::PI_OVER_2</A>' 
and '<A class=el 
href="http://ggt.sourceforge.net/html/group__Math.html#a60">gmtl::Math::PI_OVER_4</A>'. 

<P><B>How do I convert from degrees to radians?</B> 
<P>Use the deg2Rad function. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> degrees = 90;
  <FONT class=keywordtype>float</FONT> radians = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl_1_1Math.html#a45">gmtl::Math::deg2Rad</A>( degrees );
</PRE></DIV>
<P><B>How do I convert from radians to degrees?</B> 
<P>Use the rad2Deg function. 
<P></P>
<DIV class=fragment><PRE>  <FONT class=keywordtype>float</FONT> radians = 1.57;
  <FONT class=keywordtype>float</FONT> degrees = <A class=code href="http://ggt.sourceforge.net/html/namespacegmtl_1_1Math.html#a47">gmtl::Math::rad2Deg</A>( radians );
</PRE></DIV>
<P>
<HR>

<ADDRESS><SMALL>Generated on Mon Apr 7 15:29:24 2003 for 
GenericMathTemplateLibrary by <A href="http://www.doxygen.org/index.html"><IMG 
height=53 alt=doxygen src="Generic Math Template Library FAQ_files/doxygen.gif" 
width=110 align=middle border=0></A>1.2.14 written by <A 
href="mailto:dimitri@stack.nl">Dimitri van Heesch</A>, 
&nbsp;1997-2002</SMALL></ADDRESS></BODY></HTML>
